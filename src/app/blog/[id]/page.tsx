"use server";//added
import React from 'react';
import Index from "@/components/blog/Index";
import type { ResolvingMetadata, Metadata } from "next";

import { blogType, userType } from '@/components/editor/Types';
import { getErrorMessage } from '@/lib/errorBoundaries';
import prisma from "@/prisma/prismaclient";
import { redirect } from 'next/navigation';


type Props = {
    params: Promise<{ id: string }>,
    searchParams: Promise<{ [key: string]: string | string[] | undefined }>,
}
export async function generateMetadata(props: Props, parent: ResolvingMetadata): Promise<Metadata> {
    const params = await props.params;
    const id = Number(params.id)
    const singleBlog = await genMetadata({ id, parent });
    return singleBlog;
    //GENERATES AVAILABLE IDS FOR SINGLE PULL
}

export default async function page(props: { params: Promise<{ id: string }> }) {
    const params = await props.params;
    const id = Number(params.id as string);
    const blog = (await getBlog({ id })) ? await getBlog({ id }) : null;
    const user = blog ? await getUser({ user_id: blog.user_id as string }) : null;
    const style: { [key: string]: string } = { minHeight: "100vh", height: "100%", marginInline: "auto" };
    if (blog) {

        return (
            <div style={style} className="isLocal">
                <Index blog={blog} user={user} />
            </div>
        )
    } else {
        redirect("/blogs");
    }
}

export async function genMetadata(item: { id: number, parent: ResolvingMetadata }): Promise<Metadata> {
    const { id, parent } = item;
    const par = (await parent);
    const ID = Number(id);
    const blog = await getBlog({ id: ID });
    // console.log("META:blogID", blog ? blog.id : " no id")
    const title = blog?.title ? blog.title as string : "Ablogroom blogs";
    const keywds = blog?.desc ? await genKeywords({ desc: blog.desc, title }) : [];
    const url = (par?.metadataBase?.origin) ? par.metadataBase.origin : "www.ablogroom.com";
    const user = blog ? await getUser({ user_id: blog.user_id as string }) : null;
    const authors = user ? [{ name: user.name as string, url }] : undefined;
    if (user?.name) {
        keywds.push(user.name)
    };
    await prisma.$disconnect();
    return await retMetadata({ title, keywords: keywds, images: undefined, url, authors });

}

export async function retMetadata(item: { title: string | undefined, keywords: string[] | undefined, images: { url: string, width: number, height: number }[] | undefined, url: string | undefined, authors: { name: string, url: string }[] | undefined }): Promise<Metadata> {
    const { title, keywords, images, url, authors } = item;
    const initKeywords = ["The Blog Room, Free to use", "blogs for you", "web info", "free blog posts", " The World is Your Oyster", " Create Your Own Blog", "Gary's Blogs"]
    const initImgs: { url: string, width: number, height: number }[] = [
        {
            url: "/images/gb_logo.png",
            width: 600,
            height: 600
        },
        {
            url: "https://new-master.s3.ca-central-1.amazonaws.com/static/masterultils/masterUltils800_400.png",
            width: 800,
            height: 400
        },
    ];
    const initAuthors = [{ name: "Gary Wallace", url: "https://www.masterconnect.ca" }]

    const metaReturn: Metadata = {
        title: {
            default: title || "ablogroom blog",
            template: `%s | ${title || "ablogroom blog"}`,

        },

        description: ' blog page:Generated by www.masterconnect.ca,Free Blog Creation for you. It provides templates that the user can use to become an effective blogger.',
        generator: "ablogroom using Next.js",
        referrer: "origin-when-cross-origin",
        keywords: keywords ? keywords.concat(initKeywords) : initKeywords,
        authors: authors ? authors.concat(initAuthors) : initAuthors,
        creator: "Gary Wallace",
        publisher: "ablogrrom",
        formatDetection: {
            email: true,
            address: false,
            telephone: true
        },
        openGraph: {
            title: "ablogroom",
            description: 'Generated by www.masterconnect.ca,tools for you',
            url: url || "https://www.ablogroom blog",
            siteName: "ablogroom",
            images: images ? images.concat(initImgs) : initImgs,
        },
    }
    return Promise.resolve(metaReturn) as Promise<Metadata>;
};



export async function genKeywords(item: { desc: string, title: string }): Promise<string[]> {
    const { desc, title } = item;
    const words_: string[] = [title];
    const words = desc.split(" ");
    let i = 3;
    words.map((word, index) => {
        if (index > i && word.length > 2) {
            i = index - 3;
            const section = words.slice(i, index).join(" ");
            words_.push(section)
            i = index + 3;
        }
    });
    return Promise.resolve(words_);
};


export async function getBlog(item: { id: number }): Promise<blogType | null> {
    const { id } = item;
    const ID = Number(id);
    try {
        const blog = await prisma.blog.findUnique({
            where: { id: ID },
            include: {
                selectors: {
                    include: {
                        colAttr: true,
                    }
                },
                messages: true,
                elements: true,
                codes: {
                    include: {
                        linecode: true
                    }
                },
                pageCounts: true,
                charts: true
            }
        }) as unknown as blogType;
        prisma.$disconnect();
        if (blog.show) {
            return blog;
        } else {
            return null;
        };
    } catch (error) {
        const msg = getErrorMessage(error);
        console.error(msg);
        prisma.$disconnect();
        return null;
    };
};


export async function getUser(item: { user_id: string }): Promise<userType | null> {
    const { user_id } = item;
    let user: userType | null = null;
    try {
        user = await prisma.user.findUnique({
            where: { id: user_id },
            select: {
                id: true,
                name: true,
                email: true,
                password: false,
                image: true,
                imgKey: true,
                bio: true,
                showinfo: true,
                admin: true,
                username: true
            }
        }) as unknown as userType;
        if (user?.showinfo) {
            return user;
        } else {
            return null;
        }
    } catch (error) {
        const msg = getErrorMessage(error);
        console.error(msg);
        prisma.$disconnect();
        return null;

    }
};





