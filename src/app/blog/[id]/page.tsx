"use server";//added
import React from 'react';
import Index from "@/components/blog/Index";
import type { ResolvingMetadata, Metadata } from "next";
// import Meta from '@/components/meta/meta';
import { PrismaClient } from "@prisma/client"
import { blogType, userType } from '@/components/editor/Types';
import { getErrorMessage } from '@/lib/errorBoundaries';
import prisma from "@/prisma/prismaclient";


type Props = {
    params: { id: string },
    searchParams: { [key: string]: string | string[] | undefined },
}
export async function generateMetadata({ params, searchParams }: Props, parent: ResolvingMetadata): Promise<Metadata> {
    const id = Number(params.id)
    const singleBlog = await genMetadata({ id, parent });
    return singleBlog;
    //GENERATES AVAILABLE IDS FOR SINGLE PULL
}

export default async function page({ params }: { params: { id: string } }) {
    const id = Number(params.id as string);
    const blog = await getBlog({ id }) ? await getBlog({ id }) : null;
    const user = blog ? await getUser({ user_id: blog.user_id as string }) : null;
    const style: { [key: string]: string } = { minHeight: "100vh", height: "100%", marginInline: "auto" };

    return (
        <div style={style} className="isLocal">
            <Index blog={blog} user={user} />
        </div>
    )

}

export async function genMetadata(item: { id: number, parent: ResolvingMetadata }): Promise<Metadata> {
    const { id, parent } = item;
    const par = (await parent);
    const blog = await getBlog({ id: id });
    const title = blog && blog.title ? blog.title as string : "Ablogroom blogs";
    const keywds = blog && blog.desc ? await genKeywords({ desc: blog.desc, title }) : [];
    const url = (par && par.metadataBase && par.metadataBase.origin) ? par.metadataBase.origin : "www.ablogroom.com";
    const user = blog ? await getUser({ user_id: blog.user_id as string }) : null;
    const authors = user ? [{ name: user.name as string, url }] : undefined;
    if (user && user.name) {
        keywds.push(user.name)
    };
    await prisma.$disconnect();
    return await retMetadata({ title, keywords: keywds, images: undefined, url, authors });

}

export async function retMetadata(item: { title: string | undefined, keywords: string[] | undefined, images: { url: string, width: number, height: number }[] | undefined, url: string | undefined, authors: { name: string, url: string }[] | undefined }): Promise<Metadata> {
    const { title, keywords, images, url, authors } = item;
    const initKeywords = ["The Blog Room, Free to use", "blogs for you", "web info", "free blog posts", " The World is Your Oyster", " Create Your Own Blog", "Gary's Blogs"]
    const initImgs: { url: string, width: number, height: number }[] = [
        {
            url: "/images/gb_logo.png",
            width: 600,
            height: 600
        },
        {
            url: "https://new-master.s3.ca-central-1.amazonaws.com/static/masterultils/masterUltils800_400.png",
            width: 800,
            height: 400
        },
    ];
    const initAuthors = [{ name: "Gary Wallace", url: "https://www.masterconnect.ca" }]

    const metaReturn: Metadata = {
        title: {
            default: title ? title : "ablogroom blog",
            template: `%s | ${title ? title : "ablogroom blog"}`,

        },

        description: ' blog page:Generated by www.masterconnect.ca,Free Blog Creation for you. It provides templates that the user can use to become an effective blogger.',
        generator: "ablogroom using Next.js",
        referrer: "origin-when-cross-origin",
        keywords: keywords ? keywords.concat(initKeywords) : initKeywords,
        authors: authors ? authors.concat(initAuthors) : initAuthors,
        creator: "Gary Wallace",
        publisher: "ablogrrom",
        formatDetection: {
            email: true,
            address: false,
            telephone: true
        },
        openGraph: {
            title: "ablogroom",
            description: 'Generated by www.masterconnect.ca,tools for you',
            url: url ? url : "www.ablogroom.com",
            siteName: "ablogroom",
            images: images ? images.concat(initImgs) : initImgs,
        },
    }
    return new Promise((resolve) => {
        resolve(metaReturn)
    }) as Promise<Metadata>;
}
export async function genKeywords(item: { desc: string, title: string }): Promise<string[]> {
    const { desc, title } = item;
    const words_: string[] = [title];
    const words = desc.split(" ");
    let i = 3;
    words.map((word, index) => {
        if (index > i && word.length > 2) {
            i = index - 3;
            const section = words.slice(i, index).join(" ");
            words_.push(section)
            i = index + 3;
        }
    });
    return new Promise(resolve => { resolve(words_) });
}
export async function getBlog(item: { id: number }): Promise<blogType | null> {
    const { id } = item;
    let blog: blogType | null = null;
    try {
        blog = await prisma.blog.findUnique({
            where: { id: id },
            include: {
                selectors: {
                    include: {
                        colAttr: true,
                        rows: {
                            include: {
                                cols: {
                                    include: {
                                        elements: true
                                    }
                                }
                            }
                        }
                    }
                },
                messages: true,
                elements: true,
                codes: {
                    include: {
                        linecode: true
                    }
                },
                pageCounts: true,
                charts: true
            }
        }) as unknown as blogType;

    } catch (error) {
        const msg = getErrorMessage(error);
        console.error(msg);
    } finally {
        await prisma.$disconnect();
        return blog;
    }
}
export async function getUser(item: { user_id: string }): Promise<userType | null> {
    const { user_id } = item;
    let user: userType | null = null;
    try {
        user = await prisma.user.findUnique({
            where: { id: user_id },
            select: {
                id: true,
                name: true,
                email: true,
                password: false,
                image: true,
                imgKey: true,
                bio: true,
                showinfo: true,
                admin: true,
                username: true
            }
        }) as unknown as userType;
    } catch (error) {
        const msg = getErrorMessage(error);
        console.error(msg);

    } finally {
        await prisma.$disconnect();
        return user;
    }
};





