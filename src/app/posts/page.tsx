"use server";
import React from 'react'
import Index from "@/components/posts/Index";
import styles from "@/components/posts/post.module.css";
import prisma from "@/prisma/prismaclient";
import { getErrorMessage } from '@/lib/errorBoundaries';
import { postType, userSignInType, userType } from '@/components/editor/Types';
import { Metadata, ResolvingMetadata } from 'next';

type Props = {
    params: { id: string }
    searchParams: { [key: string]: string | string[] | undefined }
}
export async function generateMetadata({ params, searchParams }: Props, parent: ResolvingMetadata): Promise<Metadata> {
    const id = Number(params.id)
    const posts = await getPosts();
    const singleBlog = await genMetadata(parent, { posts });
    return singleBlog;
    //GENERATES AVAILABLE IDS FOR SINGLE PULL
}

export default async function page() {
    const posts = await getPosts() ? await getPosts() : [];
    const usersinfo = await getUsersinfo() ? await getUsersinfo() : [];
    return (
        <div className={styles.pageposts}>
            <Index posts={posts} usersinfo={usersinfo} />
        </div>
    )
}
export async function getUsersinfo(): Promise<userType[]> {
    let users: userType[] = [];
    try {
        users = await prisma.user.findMany({
            where: {
                showinfo: true
            },
            select: {
                id: true,
                name: true,
                email: true
            }
        }) as unknown as userType[];
    } catch (error) {
        const msg = getErrorMessage(error);
        console.log(msg);
    } finally {
        await prisma.$disconnect()
        return users;
    }
};
export async function getPosts(): Promise<postType[]> {
    let posts: postType[] = [];
    try {
        posts = await prisma.post.findMany({
            where: {
                published: true
            },
            select: {
                id: true,
                title: true,
                content: true,
                link: true,
                imageKey: true,
                image: true,
                date: true,
                likes: true,
                userId: true
            }
        }) as unknown as postType[];
    } catch (error) {
        const msg = getErrorMessage(error);
        console.log(msg);
    } finally {
        await prisma.$disconnect();
        return posts;
    }
}
export async function genMetadata(parent: ResolvingMetadata, { posts }: { posts: postType[] }): Promise<Metadata> {
    const par = await parent;
    let keywords: string[] = [];
    keywords = posts.map(post => (post.title));
    const contentArr = posts.sort((a, b) => { if (a.likes > b.likes) return -1; return 1 }).map(post => (post.content ? `${post.content.split(" ").slice(0, 10).join(" ")}...` : "ablogroom post")).slice(0, 4);
    keywords = keywords.concat(contentArr);
    const images = [{ url: "https://new-master.s3.ca-central-1.amazonaws.com/ablogroom/posts.png" }, { url: "https://www.ablogroom.com/images/posts.png" }]
    const desc = `Free Posts && Blogs by ABLOGROOM -Blogs Creation by Bloggers for You, such as:${contentArr.join(",")}`;
    const url = (par && par.metadataBase && par.metadataBase.origin) ? par.metadataBase.origin : "www.ablogroom.com";
    const prevImages = images || par?.openGraph?.images
    const prevDesc = desc || par.openGraph?.description;
    const prevKeywords = keywords || par.keywords;
    return {
        title: {
            default: "ablogroom Posts",
            template: `%s | "ablogroom Posts"}`,

        },
        description: prevDesc,
        generator: "ablogroom using Next.js",
        referrer: "origin-when-cross-origin",
        keywords: prevKeywords,
        authors: [{ name: "Gary Wallace", url: "https://www.masterconnect.ca" }],
        openGraph: {
            title: "Ablogroom Posts",
            description: 'Generated by www.masterconnect.ca,tools for you',
            url: "https://www.ablogroom.com/posts",
            siteName: "ablogroom",
            images: prevImages,

        }

    }
}
